<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/concept.dtd">
<concept id="conceptId">
 <title>BufferedSource</title>
 <conbody>
  <p>And so we finally get to introduce the last data type in conduits:
    <codeph>BufferedSource</codeph>. This is an abstract data type, but all it really does is keep a
   mutable reference to a buffer, and an underlying <codeph>PreparedSource</codeph>. In order to
   create one of these, you use the <codeph>bufferSource</codeph> function.</p>
  <codeblock outputclass="haskell">bufferSource ::Resource m => Source m a -&gt; ResourceT m (BufferedSource m a)</codeblock>
  <p>This one little change is what allows us to easily solve our web server dilemna. Instead of
   connecting a <codeph>Source</codeph> to our parsing <codeph>Sink</codeph>s, we use a
    <codeph>BufferedSource</codeph>. At the end of each connection, any leftover data is put back on
   the buffer. For our web server case, we can now create a <codeph>BufferedSource</codeph>, use
   that to read the request line and headers, and then pass that same
    <codeph>BufferedSource</codeph> to the application for reading the request body.</p>
 </conbody>
</concept>
