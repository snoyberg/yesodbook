<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="conceptId">
 <title>sourceState and sourceIO</title>
 <conbody>
  <p>In addition to being able to manually create <codeph>Source</codeph>s, we also have a few
   convenience functions that allow us to create most sources in a more high-level fashion.
    <codeph>sourceState</codeph> let's you write code similar to how you would use the
    <codeph>State</codeph> monad. You provide an initial state, your pull function is provided with
   the current state, and it returns a new state and a return value. Let's use this to reimplement
   sourceList.</p>
  <codeblock outputclass="haskell">-- START
import Data.Conduit
import Control.Monad.Trans.Resource

-- | Provide data from the list, one element at a time.
sourceList :: Resource m => [a] -> Source m a
sourceList state0 = sourceState
    state0
    pull
  where
    pull [] = return StateClosed
    pull (x:xs) = return $ StateOpen xs x
-- STOP
main :: IO ()
main = return ()</codeblock>
  <p>Notice the usage of the <codeph>StateClosed</codeph> and <codeph>StateOpen</codeph>
   constructors. These are very similar to <codeph>Closed</codeph> and <codeph>Open</codeph>, except
   that instead of specifying the next <codeph>Source</codeph> to be used, you provide the next
   state (here, the remainder of the list).</p>
  <p>The other common activity is to perform some I/O allocation (like opening a file), registering
   some cleanup action (closing that file), and having a function for pulling data from that
   resource. <codeph>conduit</codeph> comes built-in with a <codeph>sourceFile</codeph> function
   that gives a stream of <codeph>ByteString</codeph>s. Let's write a wildly inefficient alternative
   that returns a stream of characters.</p>
  <codeblock outputclass="haskell">-- START
import Data.Conduit
import Control.Monad.Trans.Resource
import System.IO
import Control.Monad.IO.Class (liftIO)

sourceFile :: ResourceIO m => FilePath -> Source m Char
sourceFile fp = sourceIO
    (openFile fp ReadMode)
    hClose
    (\h -> liftIO $ do
        eof &lt;- hIsEOF h
        if eof
            then return IOClosed
            else fmap IOOpen $ hGetChar h)
-- STOP
main :: IO ()
main = return ()</codeblock>
  <p>Like <codeph>sourceState</codeph>, it uses a variant on the <codeph>Open</codeph> and
    <codeph>Closed</codeph> constructors. <codeph>sourceIO</codeph> does a number of things for
   us:</p>
  <ul id="ul_rwv_vbu_se">
   <li>It registers the cleanup function with the <codeph>ResourceT</codeph> transformer, ensuring
    it gets called even in the presence of exceptions.</li>
   <li>It sets up the <codeph>sourceClose</codeph> record to release the resource immediately.</li>
   <li>As soon as you return <codeph>IOClosed</codeph>, it will release the resource.</li>
  </ul>
 </conbody>
</concept>
