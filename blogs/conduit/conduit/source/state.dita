<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="conceptId">
 <title>State</title>
 <conbody>
  <p>There is something similar about the two sources mentioned above: they never change. They
    <i>always</i> return the same value. In other words, they have no state. For almost all serious
   sources, we'll need some kind of state.</p>
  <note>The state might actually be defined outside of our program. For example, if we write a
   source that reads data from a <codeph>Handle</codeph>, we don't need to manually specify any
   state, since the <codeph>Handle</codeph> itself already has.</note>
  <p>The way we store state in a source is by updating the returned <codeph>Source</codeph> value in
   the <codeph>Open</codeph> constructor. This is best seen with an example.</p>
  <codeblock outputclass="haskell">-- START
import Data.Conduit
import Control.Monad.Trans.Resource

-- | Provide data from the list, one element at a time.
sourceList :: Resource m => [a] -> Source m a
sourceList list = Source
    { sourcePull =
        case list of
            [] -> return Closed -- no more data

            -- This is where we store our state: by return a new
            -- Source with the rest of the list
            x:xs -> return $ Open (sourceList xs) x
        , sourceClose = return ()
        }
-- STOP
main :: IO ()
main = return ()</codeblock>
  <p>Each time we pull from the source, it checks the input list. If the list is empty, pulling
   returns <codeph>Closed</codeph>, which makes sense. If the list is not empty, pulling returns
    <codeph>Open</codeph> with both the next value in the list, and a new <codeph>Source</codeph>
   value containing the rest of the input list.</p>
 </conbody>
</concept>
