<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="resources-and-type-safe-urls"><title id="x-1">Resources and type-safe URLs</title><conbody id="x-2"><p id="resources1">In our hello world, we defined just a single resource (<codeph id="x-6">HomeR</codeph>). A
            web application is usually much more exciting with more than one page on it. Let's take
            a look:</p><codeblock id="x1" outputclass="haskell">{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod "Links" [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links

getHomeR  = defaultLayout [whamlet|&lt;a href=@{Page1R}&gt;Go to page 1!|]
getPage1R = defaultLayout [whamlet|&lt;a href=@{Page2R}&gt;Go to page 2!|]
getPage2R = defaultLayout [whamlet|&lt;a href=@{HomeR}&gt;Go home!|]

main = warpDebug 3000 Links</codeblock><p id="resources2">Overall, this is very similar to Hello World. Our foundation is now
                <codeph id="x-7">Links</codeph> instead of <codeph id="x-8">HelloWorld</codeph>, and in addition to
            the <codeph id="x-9">HomeR</codeph> resource, we've added <codeph id="x-10">Page1R</codeph> and
                <codeph id="x-11">Page2R</codeph>. As such, we've also added two more handler functions:
                <codeph id="x-12">getPage1R</codeph> and <codeph id="x-13">getPage2R</codeph>.</p><p id="resources3">The only truly new feature is inside the <codeph id="x-14">whamlet</codeph>
            quasi-quotation. We'll delve into syntax in the <xref id="x-15" href="../shakespearean-templates/shakespearean-templates.dita#shakespearean-templates" format="dita">Shakespeare chapter</xref>, but we can see that:</p><codeblock outputclass="hamlet" id="x2">&lt;a href=@{Page1R}&gt;Go to page 1!</codeblock><p id="resources4">creates a link to the <codeph id="x-16">Page1R</codeph> resource. The important thing to
            note here is that <codeph id="x-17">Page1R</codeph> is a data constructor. By making each resource
            a data constructor, we have a feature called <term id="x3">type-safe URLs</term>.
            Instead of splicing together strings to create URLs, we simply create a plain old
            Haskell value. By using at-sign interpolation (<codeph id="x-18">@{...}</codeph>), Yesod
            automatically renders those values to textual URLs before sending things off to the
            user. We can see how this is implemented by looking again at the
                <cmdname id="x-19">-ddump-splices</cmdname> output:</p>
        <codeblock id="x-20" outputclass="haskell">{-# LANGUAGE TypeFamilies, OverloadedStrings #-}
import Yesod.Core

data Links = Links

-- START
instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])
-- STOP

main :: IO ()
main = return ()</codeblock>
        <p id="x-21">In the <codeph id="x-22">Route</codeph> associated type for <codeph id="x-23">Links</codeph>, we have
            additional constructors for <codeph id="x-24">Page1R</codeph> and <codeph id="x-25">Page2R</codeph>. We also
            now have a better glimpse of the return values for <codeph id="x-26">returnRoute</codeph>. The
            first part of the tuple gives the <term id="x-27">path pieces</term> for the given route. The
            second part gives the query string parameters; for almost all use cases, this will be an
            empty list.</p>
        <p id="x-3">It's hard to over-estimate the value of type-safe URLs. They give you a huge
            amount of flexibility and robustness when developing your application. You can move URLs
            around at will without ever breaking links. <xref id="x-4" href="../routing-and-handlers/routing-and-handlers.dita#routing-and-handlers" format="dita">In the routing chapter</xref>, we'll see that routes can take
            parameters, such as a blog entry URL taking the blog post ID.</p>
        <p id="x-5">Let's say you want to switch from routing on the numerical post ID to a
            year/month/slug setup. In a traditional web framework, you would need to go through
            every single reference to your blog post route and update appropriately. If you miss
            one, you'll have 404s at runtime. In Yesod, all you do is update your route and compile:
            GHC will pinpoint every single line of code that needs to be corrected.</p></conbody></concept>
