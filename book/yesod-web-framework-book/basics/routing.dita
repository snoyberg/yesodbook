<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="routing"><title id="x-1">Routing</title><conbody id="x-2"><p id="routing1">Like most modern web frameworks, Yesod follows a <xref id="x1" href="http://en.wikipedia.org/wiki/Front_Controller_pattern" scope="external" format="html">front controller pattern</xref>. This means that every request to a
            Yesod application enters at the same point and is routed from there. As a contrast, in
            systems like PHP and ASP you usually create a number of different files, and the web
            server automatically directs requests to the relevant file.</p>
        <p id="x-3">In addition, Yesod uses a declarative style for specifying routes. In our example above,
            this looked like:</p>
        <codeblock id="x-4" outputclass="haskell">mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]</codeblock>
        <note id="x-10"><codeph id="x-11">mkYesod</codeph> is a Template Haskell function, and
                <codeph id="x-12">parseRoutes</codeph> is a QuasiQuoter.</note>
        <p id="x-5">In English, all this means is: <q id="x-6">In the HelloWorld application, create
                one route. I'd like to call it <codeph id="x-13">HomeR</codeph>, it should listen for requests
                to <codeph id="x-7">/</codeph> (the root of the application), and should answer
                    <codeph id="x-14">GET</codeph> requests</q>. We call <codeph id="x-15">HomeR</codeph> a <term id="x-8">resource</term>, which is where the "R" suffix comes from.<note id="x-9">The R suffix on resource names is simply convention, but it's a fairly universally
                followed convention. It makes it just a bit easier to read and understand
                code.</note></p>
        <p id="x-16">The <codeph id="x-17">mkYesod</codeph> TH function generates quite a bit of code here: a route data
            type, a dispatch function, and a render function. We'll look at this in more detail in
                <xref id="x-18" href="../routing-and-handlers/routing-and-handlers.dita#routing-and-handlers" format="dita">the routing chapter</xref>. But by using the
                <codeph id="x-19">-ddump-splices</codeph> GHC option, we can get an immediate look at the
            generated code. A much cleaned up version of it is:</p>
        <codeblock id="x-20" outputclass="haskell">{-# LANGUAGE TypeFamilies, MultiParamTypeClasses, OverloadedStrings #-}
import Yesod.Routes.Dispatch hiding (Route)
import qualified Yesod.Routes.Dispatch
import Yesod.Routes.Class
import Yesod.Core

data HelloWorld = HelloWorld

-- START
instance RenderRoute HelloWorld where
  data Route HelloWorld = HomeR
    deriving (Show, Eq, Read)
  renderRoute HomeR = ([], [])

instance YesodDispatch HelloWorld HelloWorld where
    yesodDispatch master sub toMaster app404 app405 method pieces =
        case dispatch pieces of
            Just f -&gt; f
                master
                sub
                toMaster
                app404
                app405
                method
            Nothing -&gt; app404
      where
        dispatch = Yesod.Routes.Dispatch.toDispatch
            [ Yesod.Routes.Dispatch.Route [] False onHome
            ]
        onHome [] = Just $ \master sub toMaster _app404 app405 method -&gt;
            case method of
                "GET" -&gt; yesodRunner
                    (fmap chooseRep getHomeR)
                    master
                    sub
                    (Just HomeR)
                    toMaster
                _ -&gt; app405 HomeR
-- STOP

getHomeR = return ()

main :: IO ()
main = return ()</codeblock>
        <p id="x-21">Some of that will likely not make sense yet. In particular, the implementation of
                <codeph id="x-22">yesodDispatch</codeph> is a bit hairy to accomodate different dispatch
            approaches and fit the model necessary for our high-performance routing structures.
            However, the <codeph id="x-23">RenderRoute</codeph> implementation with its associated data type
            should already give you a good feel for what's going on under the surface.</p></conbody></concept>
