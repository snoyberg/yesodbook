<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="searching">
 <title id="x-1">Searching</title>
 <conbody id="x-2">
  <p id="x-3">Now that we've got the boring stuff out of the way, let's jump into the actual searching. We're
   going to need three pieces of information for displaying a result: the document ID it comes from,
   the title of that document, and the <term id="x-4">excerpts</term>. Excerpts are the highlighted portions
   of the document which contain the search term.</p>
  <fig id="x-5">
   <title id="x-6">Search Result</title>
   <image href="search-results.png" id="image_dba_loh_rd"/>
  </fig>
  <p id="x-7">So let's start off by defining a Result datatype:</p>
  <codeblock id="x-8" outputclass="haskell">data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }</codeblock>
  <p id="x-9">Next we'll look at the search handler:</p>
  <codeblock id="x-10" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Data.Text (Text, unpack)
import Control.Applicative ((&lt;$>), (&lt;*>))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedLazyText)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher where
    approot _ = ""

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage

addDocForm :: Html -> MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$> areq textField "Title" Nothing
    &lt;*> areq textareaField "Contents" Nothing

searchForm :: Html -> MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing

getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p>Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}>
    &lt;table>
        ^{docWidget}
        &lt;tr>
            &lt;td colspan=3>
                &lt;input type=submit value="Add document">
&lt;form method=get action=@{SearchR}>
    ^{searchWidget}
    &lt;input type=submit value=Search>
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -> do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -> defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}>
    &lt;table>
        ^{docWidget}
        &lt;tr>
            &lt;td colspan=3>
                &lt;input type=submit value="Add document">
|]

getDocR :: DocId -> Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1>#{docTitle doc}
&lt;div .content>#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -> Doc -> Text -> IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [T.unpack $ escape $ docContent doc]
        "searcher"
        (unpack qstring)
    let excerpt =
            case excerpt' of
                ST.Ok bss -> preEscapedLazyText $ decodeUtf8With ignore $ L.concat bss
                _ -> return ()
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -> Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '>' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

getResults :: Text -> Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" (unpack qstring)
    case sphinxRes' of
        ST.Ok sphinxRes -> do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -> do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -> return Nothing
                    Just doc -> liftIO $ Just &lt;$> getResult docid doc qstring
        _ -> error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }

-- START
getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -> getResults qstring
            _ -> return []
    defaultLayout $ do
        addLucius [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}>
    ^{searchWidget}
    &lt;input type=submit value=Search>
$if not $ null searchResults
    &lt;h1>Results
    $forall result &lt;- searchResults
        &lt;div .result>
            &lt;a href=@{DocR $ resultId result}>#{resultTitle result}
            &lt;div .excerpt>#{resultExcerpt result}
|]
-- STOP

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
    sendWaiResponse $ ResponseSource status200 headers source

entityToEvents :: (Entity SqlPersist Doc) -> [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -> C.Source IO X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -> C.Source IO X.Event
docSource conn = selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -> X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -> do
    runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
  <p id="x-11">Nothing magical here, we're just relying on the <codeph>searchForm</codeph> defined
            above, and the <codeph>getResults</codeph> function which hasn't been defined yet. This
            function just takes a search string, and returns a list of results. This is where we
            first interact with the Sphinx API. We'll be using two functions: <codeph>query</codeph>
            will return a list of matches, and <codeph>buildExcerpts</codeph> will return the
            highlighted excerpts. Let's first look at <codeph>query</codeph>:</p>
  <codeblock id="x-12" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Data.Text (Text, unpack)
import Control.Applicative ((&lt;$>), (&lt;*>))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedLazyText)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher where
    approot _ = ""

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage

addDocForm :: Html -> MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$> areq textField "Title" Nothing
    &lt;*> areq textareaField "Contents" Nothing

searchForm :: Html -> MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing

getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p>Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}>
    &lt;table>
        ^{docWidget}
        &lt;tr>
            &lt;td colspan=3>
                &lt;input type=submit value="Add document">
&lt;form method=get action=@{SearchR}>
    ^{searchWidget}
    &lt;input type=submit value=Search>
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -> do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -> defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}>
    &lt;table>
        ^{docWidget}
        &lt;tr>
            &lt;td colspan=3>
                &lt;input type=submit value="Add document">
|]

getDocR :: DocId -> Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1>#{docTitle doc}
&lt;div .content>#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -> Doc -> Text -> IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [T.unpack $ escape $ docContent doc]
        "searcher"
        (unpack qstring)
    let excerpt =
            case excerpt' of
                ST.Ok bss -> preEscapedLazyText $ decodeUtf8With ignore $ L.concat bss
                _ -> return ()
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -> Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '>' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

-- START
getResults :: Text -> Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" (unpack qstring)
    case sphinxRes' of
        ST.Ok sphinxRes -> do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -> do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -> return Nothing
                    Just doc -> liftIO $ Just &lt;$> getResult docid doc qstring
        _ -> error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }
-- STOP

getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -> getResults qstring
            _ -> return []
    defaultLayout $ do
        addLucius [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}>
    ^{searchWidget}
    &lt;input type=submit value=Search>
$if not $ null searchResults
    &lt;h1>Results
    $forall result &lt;- searchResults
        &lt;div .result>
            &lt;a href=@{DocR $ resultId result}>#{resultTitle result}
            &lt;div .excerpt>#{resultExcerpt result}
|]

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
    sendWaiResponse $ ResponseSource status200 headers source

entityToEvents :: (Entity SqlPersist Doc) -> [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -> C.Source IO X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -> C.Source IO X.Event
docSource conn = selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -> X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -> do
    runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
  <p id="x-13"><codeph>query</codeph> takes three parameters: the configuration options, the index
            to search against (searcher in this case) and the search string. It returns a list of
            document IDs that contain the search string. The tricky bit here is that those documents
            are returned as <codeph id="x-14">Int64</codeph> values, whereas we need <codeph
                id="x-15">DocId</codeph>s. We're taking advantage of the fact that the SQL
            Persistent backends use a <codeph>PersistInt64</codeph> constructor for their IDs, and
            simply wrap up the values appropriately.</p>
  <note id="x-16">If you're dealing with a backend that has non-numeric IDs, like MongoDB, you'll need to work
   out something a bit more clever than this.</note>
  <p id="x-17">We then loop over the resulting IDs to get a <codeph id="x-18">[Maybe Result]</codeph> value, and use
    <codeph id="x-19">catMaybes</codeph> to turn it into a <codeph id="x-20">[Result]</codeph>. In the where clause, we
   define our local settings, which override the default port and set up the search to work when
    <i id="x-21">any</i> term matches the document.</p>
  <p id="x-22">Let's finally look at the <codeph>getResult</codeph> function:</p>
  <codeblock id="x-23" outputclass="haskell">getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [T.unpack $ escape $ docContent doc]
        "searcher"
        (unpack qstring)
    let excerpt =
            case excerpt' of
                ST.Ok bss -&gt; preEscapedLazyText $ decodeUtf8With ignore $ L.concat bss
                _ -&gt; return ()
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c</codeblock>
  <p id="x-24"><codeph>buildExcerpts</codeph> takes four parameters: the configuration options, the
            textual contents of the document, the search index and the search term. The interesting
            bit is that we entity escape the text content. Sphinx won't automatically escape these
            for us, so we must do it explicitly.</p>
  <p id="x-25">Similarly, the result from Sphinx is a list of lazy ByteStrings. But of course, we'd rather
   have Html. So we concat that list into a single lazy ByteString, decode it to a lazy text
   (ignoring invalid UTF-8 character sequences), and use preEscapedLazyText to make sure that the
   tags inserted for matches are not escaped. A sample of this HTML is:</p>
  <codeblock id="x-26" outputclass="html">&amp;#8230; Departments.  The President shall have &lt;span class='match'&gt;Power&lt;/span&gt; to fill up all Vacancies
&amp;#8230;  people. Amendment 11 The Judicial &lt;span class='match'&gt;power&lt;/span&gt; of the United States shall
&amp;#8230; jurisdiction. 2. Congress shall have &lt;span class='match'&gt;power&lt;/span&gt; to enforce this article by
&amp;#8230; 5. The Congress shall have &lt;span class='match'&gt;power&lt;/span&gt; to enforce, by appropriate legislation
&amp;#8230;</codeblock>
 </conbody>
</concept>
