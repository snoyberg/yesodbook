<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="conceptId" outputclass="xmlpipe">
 <title id="x-1">Streaming xmlpipe output</title>
 <conbody id="x-2">
  <p id="x-3">We've saved the best for last. For the majority of Yesod handlers, the recommended approach is
   to load up the database results into memory and then produce the output document based on that.
   It's simpler to work with, but more importantly it's more resilient to exceptions. If there's a
   problem loading the data from the database, the user will get a proper 500 response code.</p>
  <note id="x-4">What do I mean by "proper 500 response code?" If you start streaming a response to a client,
   and encounter an exception halfway through, there's no way to change the status code; the user
   will see a 200 response that simply stops in the middle. Not only can this partial content be
   confusing, but it's an invalid usage of the HTTP spec.</note>
  <p id="x-5">However, generating the xmlpipe output is a perfect example of the alternative. There are
   potentially a huge number of documents (the yesodweb.com code handles tens of thousands of
   these), and documents could easily be several hundred kilobytes. If we take a non-streaming
   approach, this can lead to huge memory usage and slow response times.</p>
  <p id="x-6">So how exactly do we create a streaming response? As we cover in <xref id="x-7"
    href="../web-application-interface/web-application-interface.dita#web-application-interface"
    format="dita">the WAI chapter</xref>, we have a <codeph>ResponseSource</codeph> constructor that
   uses a stream of blaze-builder <codeph id="x-8">Builder</codeph>s. From the Yesod side, we can
   avoid the normal Yesod response procedure and send a WAI response directly using the <codeph
    id="x-9">sendWaiResponse</codeph> function. So there are at least two of the pieces of this
   puzzle.</p>
  <p id="x-10">Now we know we want to create a stream of <codeph>Builder</codeph>s from some XML
   content. Fortunately, the <apiname id="x-11">xml-conduit</apiname> package provides this
   interface directly. <codeph>xml-conduit</codeph> provides some high-level interfaces for dealing
   with documents as a whole, but in our case, we're going to need to use the low-level Event
   interface to ensure minimal memory impact. So the function we're interested in is:</p>
  <codeblock id="x-12" outputclass="haskell">renderBuilder :: Resource m =&gt; RenderSettings -&gt; Conduit Event m Builder b</codeblock>
  <p id="x-13">In plain English, that means renderBytes takes some settings (we'll just use the
   defaults), and will then convert a stream of <codeph>Event</codeph>s to a stream of
    <codeph>Builder</codeph>s. This is looking pretty good, all we need now is a stream of
    <codeph>Event</codeph>s.</p>
  <p id="x-14">Speaking of which, what should our XML document actually look like? It's pretty
   simple, we have a <codeph id="x-15">sphinx:docset</codeph> root element, a <codeph id="x-16"
    >sphinx:schema</codeph> element containing a single <codeph id="x-17">sphinx:field</codeph>
   (which defines the content field), and then a <codeph id="x-18">sphinx:document</codeph> for each
   document in our database. That last element will have an <codeph>id</codeph> attribute and a
   child <codeph id="x-19">content</codeph> element.</p>
  <fig id="x-20">
   <title id="x-21">Sample xmlpipe document</title>
   <codeblock id="x-22" outputclass="xml">&lt;sphinx:docset xmlns:sphinx="http://sphinxsearch.com/"&gt;
    &lt;sphinx:schema&gt;
        &lt;sphinx:field name="content"/&gt;
    &lt;/sphinx:schema&gt;
    &lt;sphinx:document id="1"&gt;
        &lt;content&gt;bar&lt;/content&gt;
    &lt;/sphinx:document&gt;
    &lt;sphinx:document id="2"&gt;
        &lt;content&gt;foo bar baz&lt;/content&gt;
    &lt;/sphinx:document&gt;
&lt;/sphinx:docset&gt;</codeblock>
  </fig>
  <p id="x-23">Every document is going to start off with the same events (start the docset, start
   the schema, etc) and end with the same event (end the docset). We'll start off by defining
   those:</p>
  <codeblock id="x-24" outputclass="haskell">toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]</codeblock>
  <p id="x-25">Now that we have the shell of our document, we need to get the <codeph id="x-26"
    >Event</codeph>s for each individual document. This is actually a fairly simple function:</p>
  <codeblock id="x-27" outputclass="haskell">entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]</codeblock>
  <p id="x-28">We start the document element with an <codeph>id</codeph> attribute, start the
   content, insert the content, and then close both elements. We use <codeph>toPathPiece</codeph> to
   convert a <codeph>DocId</codeph> into a <codeph>Text</codeph> value. Next, we need to be able to
   convert a stream of these entities into a stream of events. For this, we can use the built-in
    <codeph>concatMap</codeph> function from <codeph>Data.Conduit.List</codeph>: <codeph id="x-29"
    >CL.concatMap entityToEvents</codeph>.</p>
  <p id="x-30">But what we <i id="x-31">really</i> want is to stream those events directly from the
   database. For most of this book, we've used the <codeph>selectList</codeph> function, but
   Persistent also provides the (more powerful) <codeph>selectSourceConn</codeph> function. So we
   end up with the function:</p>
  <codeblock id="x-32" outputclass="haskell">docSource :: Connection -> C.Source IO X.Event
docSource conn = selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents</codeblock>
  <p id="x-33">The $= operator joins together a source and a conduit into a new source. Now that we
   have our <codeph>Event</codeph> source, all we need to do is surround it with the document start
   and end events. With <codeph>Source</codeph>'s <codeph>Monoid</codeph> instance, this is a piece
   of cake:</p>
  <codeblock id="x-34" outputclass="haskell">fullDocSource :: Connection -> C.Source IO X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]</codeblock>
  <p id="x-35">We're almost there, now we just need to tie it together in
    <codeph>getXmlpipeR</codeph>. We need to get a database connection to be used. Normally,
   database connections are taken and returned automatically via the <codeph>runDB</codeph>
   function. In our case, we want to check out a connection and keep it available until the response
   body is completely sent. To do this, we use the <codeph>takeResource</codeph> function, which
   registers a cleanup action with the <codeph>ResourceT</codeph> monad.</p>
  <note>All WAI applications live in a <codeph>ResourceT</codeph> transformer. You can get more
   information on <codeph>ResourceT</codeph> in the <xref href="../conduit/conduits.dita#conceptId"
    format="dita">conduit appendix</xref>.</note>
  <p id="x-36">By default, a resource will not be returned to the pool. This has to do with proper
   exception handling, but is not relevant for our use case. Therefore, we need to force the
   connection to be returned to the pool.</p>
  <codeblock id="x-37" outputclass="haskell">getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True let source = fullDocSource conn C.$= renderBuilder def
    sendWaiResponse $ ResponseSource status200 headers source</codeblock>
  <p id="x-38">We get our connection pool from the foundation variable, then send a WAI response. We
   use the <codeph>ResponseSource</codeph> constructor, and provide it the status code, response
   headers, and body.</p>
 </conbody>
</concept>
