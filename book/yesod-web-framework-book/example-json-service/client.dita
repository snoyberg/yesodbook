<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="client"><title id="x-1">Client</title><conbody id="x-2">
  <p id="x1"><apiname id="x2">http-conduit</apiname> was written as a companion to WAI. It too uses
    <codeph id="x-3">conduit</codeph> and <codeph id="x-4">blaze-builder</codeph> pervasively, meaning we once again
   get easy interop with <codeph id="x-5">aeson</codeph>. A few extra comments for those not familiar with
    <codeph id="x-6">http-conduit</codeph>:</p>
  <ul id="ul_4be25b01-52e2-414f-ba22-d6c0b97232c8">
   <li id="x3">A <codeph id="x4">Manager</codeph> is present to keep track of open connections, so
    that multiple requests to the same server use the same connection. You usually want to use the
     <codeph id="x5">withManager</codeph> function to create and clean up this
     <codeph id="x-7">Manager</codeph>, since it is exception safe.</li>
   <li id="x6">We need to know the size of our request body, which can't be determined directly from
    a <codeph id="x-8">Builder</codeph>. Instead, we convert the <codeph id="x-9">Builder</codeph> into a lazy
     <codeph id="x-10">ByteString</codeph> and take the size from there.</li>
   <li id="x7">There are a number of different functions for initiating a request. We use
     <codeph id="x-11">http</codeph>, which allows us to directly access the data stream. There are other
    higher level functions (such as <codeph id="x-12">httpLbs</codeph>) that let you ignore the issues of
    sources and get the entire body directly.</li>
  </ul>
  <codeblock outputclass="haskell" id="x8">{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit
    ( http, parseUrl, withManager, RequestBody (RequestBodyLBS)
    , requestBody, method, Response (..)
    )
import Data.Aeson (Value (Object, String))
import Data.Aeson.Parser (json)
import Data.Conduit (($$))
import Data.Conduit.Attoparsec (sinkParser)
import Control.Monad.IO.Class (liftIO)
import Data.Aeson (encode, (.=), object)

main :: IO ()
main = withManager $ \manager -&gt; do
    value &lt;- liftIO makeValue
    -- We need to know the size of the request body, so we convert to a
    -- ByteString
    let valueBS = encode value
    req' &lt;- liftIO $ parseUrl "http://localhost:3000/"
    let req = req' { method = "POST", requestBody = RequestBodyLBS valueBS }
    Response status headers body &lt;- http req manager
    resValue &lt;- body $$ sinkParser json
    liftIO $ handleResponse resValue

-- Application-specific function to make the request value
makeValue :: IO Value
makeValue = return $ object
    [ ("foo" .= ("bar" :: String))
    ]

-- Application-specific function to handle the response from the server
handleResponse :: Value -&gt; IO ()
handleResponse = print</codeblock>
 </conbody></concept>