<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="server"><title id="x-1">Server</title><conbody id="x-2">
  <p id="x1">WAI uses the <apiname id="x2">conduit</apiname> package to handle streaming request
            bodies, and efficiently generates responses using <apiname id="x3"
                >blaze-builder</apiname>. <apiname id="x4">aeson</apiname> uses <apiname id="x5"
                >attoparsec</apiname> for parsing; by using <apiname id="x6"
                >attoparsec-conduit</apiname> we get easy interoperability with WAI. This plays out
            as:</p>
  <codeblock outputclass="haskell" id="x7">{-# LANGUAGE OverloadedStrings #-}
import Network.Wai (Response, responseLBS, Application, requestBody)
import Network.HTTP.Types (status200, status400)
import Network.Wai.Handler.Warp (run)
import Data.Aeson.Parser (json)
import Data.Conduit.Attoparsec (sinkParser)
import Control.Monad.IO.Class (liftIO)
import Data.Aeson (Value, encode, object, (.=))
import Control.Exception (SomeException)
import Data.ByteString (ByteString)
import Data.Conduit (ResourceT, ($$))
import Control.Exception.Lifted (handle)

main :: IO ()
main = run 3000 app

app :: Application
app req = handle invalidJson $ do
    value &lt;- requestBody req $$ sinkParser json
    newValue &lt;- liftIO $ modValue value
    return $ responseLBS
        status200
        [("Content-Type", "application/json")]
        $ encode newValue

invalidJson :: SomeException -&gt; ResourceT IO Response
invalidJson ex = return $ responseLBS
    status400
    [("Content-Type", "application/json")]
    $ encode $ object
        [ ("message" .= show ex)
        ]

-- Application-specific logic would go here.
modValue :: Value -&gt; IO Value
modValue = return</codeblock>
 </conbody></concept>