<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="create-aforms"><title id="x-1">Create AForms</title><conbody id="x-2">
  <p id="x1">Now that I've (hopefully) convinced you that in our synopsis we were really dealing with
   applicative forms, let's have a look and try to understand how these things get created. Let's
   take a simple example:</p>
  <codeblock id="x2" outputclass="haskell">{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
    OverloadedStrings, TypeFamilies #-}
import Yesod
import Yesod.Form.Jquery
import Data.Time (Day)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

data Synopsis = Synopsis

mkYesod "Synopsis" [parseRoutes|
/car CarR GET
|]

instance Yesod Synopsis

-- Necessary for i18n. The default function uses English.
instance RenderMessage Synopsis FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 Synopsis

-- START
data Car = Car
    { carModel :: Text
    , carYear :: Int
    }
  deriving Show

carAForm :: AForm Synopsis Synopsis Car
carAForm = Car
    &lt;$&gt; areq textField "Model" Nothing
    &lt;*&gt; areq intField "Year" Nothing

carForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable carAForm
-- STOP

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) &lt;- runFormGet carForm
    case result of
        FormSuccess car -&gt; defaultLayout [whamlet|&lt;p&gt;#{show car}|]
        _ -&gt; defaultLayout [whamlet|
&lt;form method=get action=@{CarR} enctype=#{enctype}&gt;
    &lt;table&gt;
        ^{widget}
    &lt;input type=submit&gt;
|]</codeblock>
  <p id="x3">Here, we've explicitly split up applicative and monadic forms. In
                <codeph id="x-3">carAForm</codeph>, we use the <codeph id="x-4">&lt;$&gt;</codeph> and
                <codeph id="x-5">&lt;*&gt;</codeph> operators. This should not be surprising; these are
            almost always used in applicative-style code. (For more information on applicative code,
            see <xref id="x4" href="http://www.haskell.org/haskellwiki/Applicative_functor" format="html" scope="external">the Haskell wiki</xref>.) And we have one line for
            each record in our <codeph id="x-6">Car</codeph> datatype. Perhaps unsurprisingly, we have a
                <codeph id="x-7">textField</codeph> for the <codeph id="x-8">Text</codeph> record, and an
                <codeph id="x-9">intField</codeph> for the <codeph id="x-10">Int</codeph> record.</p>
  <p id="x5">Let's look a bit more closely at the <codeph id="x-11">areq</codeph> function. Its (simplified)
            type signature is <codeph id="x6">Field a -&gt; FieldSettings -&gt; Maybe a -&gt; AForm
                a</codeph>. So that first argument is going to determine the datatype of this field,
            how to parse it, and how to render it. The next argument,
            <codeph id="x-12">FieldSettings</codeph>, tells us the label, tooltip, name and ID of the field.
            In this case, we're using the previously-mentioned <codeph id="x-13">IsString</codeph> instance of
                <codeph id="x-14">FieldSettings</codeph>.</p>
  <p id="x7">And what's up with that <codeph id="x-15">Maybe a</codeph>? It provides the optional default
            value. For example, if we want our form to fill in "2007" as the default car year, we
            would use <codeph id="x8">areq intField "Year" (Just 2007)</codeph>. We can even take
            this to the next level, and have a form that takes an optional parameter giving the
            default values.</p>
  <fig id="x9">
   <title id="x10">Form with default values</title>
   <codeblock id="x11" outputclass="haskell">{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
    OverloadedStrings, TypeFamilies #-}
import Yesod
import Yesod.Form.Jquery
import Data.Time (Day)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

data Synopsis = Synopsis

mkYesod "Synopsis" [parseRoutes|
/car CarR GET
|]

instance Yesod Synopsis

-- Necessary for i18n. The default function uses English.
instance RenderMessage Synopsis FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 Synopsis

data Car = Car
    { carModel :: Text
    , carYear :: Int
    }
  deriving Show

-- START
carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq intField "Year" (carYear &lt;$&gt; mcar)
-- STOP

carForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable (carAForm $ Just $ Car "Forte" 2010)

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) &lt;- runFormGet carForm
    case result of
        FormSuccess car -&gt; defaultLayout [whamlet|&lt;p&gt;#{show car}|]
        _ -&gt; defaultLayout [whamlet|
&lt;form method=get action=@{CarR} enctype=#{enctype}&gt;
    &lt;table&gt;
        ^{widget}
    &lt;input type=submit&gt;
|]</codeblock>
  </fig>
 </conbody></concept>
