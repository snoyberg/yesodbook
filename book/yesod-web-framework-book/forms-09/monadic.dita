<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/concept.dtd">
<concept id="monadic">
    <title id="x-1">Monadic Forms</title>
    <conbody id="x-2">
        <p id="x-3">Often times, a simple form layout is adequate, and applicative forms excel at
            this approach. Sometimes, however, you'll want to have a more customized look to your
            form.</p>
        <fig id="x-4">
            <title id="x-5">A non-standard form layout</title>
            <image id="image_d604c9d5-b1e2-447a-a3ee-efe4559f0d2f" href="monadic-form.png"/>
        </fig>
        <p id="x-6">For these use cases, monadic forms fit the bill. They are a bit more verbose
            than their applicative cousins, but this verbosity allows you to have complete control
            over what the form will look like. In order to generate the form above, we could code
            something like this.</p>
        <codeblock id="x-7" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, MultiParamTypeClasses #-}
import Yesod
import Control.Applicative
import Data.Text (Text)

data Monadic = Monadic

mkYesod "Monadic" [parseRoutes|
/ RootR GET
|]

instance Yesod Monadic

instance RenderMessage Monadic FormMessage where
    renderMessage _ _ = defaultFormMessage

data Person = Person { personName :: Text, personAge :: Int }
    deriving Show

personForm :: Html -&gt; MForm Monadic Monadic (FormResult Person, Widget)
personForm extra = do
    (nameRes, nameView) &lt;- mreq textField "this is not used" Nothing
    (ageRes, ageView) &lt;- mreq intField "neither is this" Nothing
    let personRes = Person &lt;$&gt; nameRes &lt;*&gt; ageRes
    let widget = do
            toWidget [lucius|
##{fvId ageView} {
    width: 3em;
}
|]
            [whamlet|
#{extra}
&lt;p&gt;
    Hello, my name is #
    ^{fvInput nameView}
    \ and I am #
    ^{fvInput ageView}
    \ years old. #
    &lt;input type=submit value="Introduce myself"&gt;
|]
    return (personRes, widget)

getRootR :: Handler RepHtml
getRootR = do
    ((res, widget), enctype) &lt;- runFormGet personForm
    defaultLayout [whamlet|
&lt;p&gt;Result: #{show res}
&lt;form enctype=#{enctype}&gt;
    ^{widget}
|]

main :: IO ()
main = warpDebug 3000 Monadic</codeblock>
        <p id="x-8">Similar to the applicative <codeph id="x-9">areq</codeph>, we use <codeph id="x-10">mreq</codeph> for monadic forms. (And yes, there's also
                <codeph id="x-19">mopt</codeph> for optional fields.) But there's a big difference:
                <codeph id="x-20">mreq</codeph> gives us back a pair of values. Instead of hiding away the
                <apiname id="x-11">yesod-form:Yesod.Form.Types:FieldView</apiname> value and
            automatically inserting it into a widget, we get the control to insert it as we see
            fit.</p>
        <p id="x-12"><codeph id="x-21">FieldView</codeph> has a number of pieces of information. The most
            important is <codeph id="x-22">fvInput</codeph>, which is the actual form field. In this example,
            we also use <codeph id="x-23">fvId</codeph>, which gives us back the HTML <codeph id="x-24">id</codeph>
            attribute of the input tag. In our example, we use that to specify the width of the
            field.</p>
        <p id="x-13">You might be wondering what the story is with the "this is not used" and
            "neither is this" values. <codeph id="x-25">mreq</codeph> takes a <codeph id="x-26"
                >FieldSettings</codeph> as its second argument. Since <codeph>FieldSettings</codeph>
            provides an <codeph>IsString</codeph> instance, the strings are essentially expanded by
            the compiler
            to:<codeblock outputclass="haskell">fromString "this is not used" == FieldSettings
    { fsLabel = "this is not used"
    , fsTooltip = Nothing
    , fsId = Nothing
    , fsName = Nothing
    , fsClass = []
    }</codeblock>In
            the case of applicative forms, the <codeph>fsLabel</codeph> and
                <codeph>fsTooltip</codeph> values are used when constructing your HTML. In the case
            of monadic forms, Yesod does not generate any of the "wrapper" HTML for you, and
            therefore these values are ignored.</p>
        <p id="x-14">The other interesting bit is the <codeph id="x-15">extra</codeph> value.
                <codeph id="x-33">GET</codeph> forms include an extra field to indicate that they have been
            submitted, and <codeph id="x-34">POST</codeph> forms include a security tokens to prevent CSRF
            attacks. If you don't include this extra hidden field in your form, Yesod will not
            accept it.</p>
        <p id="x-16">Other than that, things are pretty straight-forward. We create our
                <codeph id="x-35">personRes</codeph> value by combining together the <codeph id="x-36">nameRes</codeph>
            and <codeph id="x-37">ageRes</codeph> values, and then return a tuple of the person and the
            widget. And in the <codeph id="x-38">getRootR</codeph> function, everything looks just like an
            applicative form. In fact, you could swap out our monadic form with an applicative one
            and the code would still work.</p>
        <note id="x-17">Well, that's not <b id="x-18">exactly</b> true. It would compile and build,
            but you wouldn't have a submit button.</note>
    </conbody>
</concept>
