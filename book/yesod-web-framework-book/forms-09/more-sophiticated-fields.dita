<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="more-sophiticated-fields"><title id="x-1">More sophisticated fields</title><conbody id="x-2">
  <p id="x1">Our color entry field is nice, but it's not exactly user-friendly. What we really want
            is a drop-down list.</p>
  <fig id="x2">
   <title id="x3">Drop-down lists</title>
   <codeblock id="x4" outputclass="haskell">{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
    OverloadedStrings, TypeFamilies #-}
import Yesod
import Yesod.Form.Jquery
import Data.Time (Day, getCurrentTime, utctDay, toGregorian)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

data Synopsis = Synopsis

mkYesod "Synopsis" [parseRoutes|
/car CarR GET
|]

instance Yesod Synopsis

-- Necessary for i18n. The default function uses English.
instance RenderMessage Synopsis FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 Synopsis

-- START
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField "Year" (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (selectFieldList colors) "Color" (carColor &lt;$&gt; mcar)
  where
    colors :: [(Text, Color)]
    colors = [("Red", Red), ("Blue", Blue), ("Gray", Gray), ("Black", Black)]
-- STOP
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = checkM inPast $ checkBool (&gt;= 1990) errorMessage intField

    inPast y = do
        thisYear &lt;- liftIO getCurrentYear
        return $ if y &lt;= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now &lt;- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year

carForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just Black

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) &lt;- runFormGet carForm
    case result of
        FormSuccess car -&gt; defaultLayout [whamlet|&lt;p&gt;#{show car}|]
        _ -&gt; defaultLayout [whamlet|
&lt;form method=get action=@{CarR} enctype=#{enctype}&gt;
    &lt;table&gt;
        ^{widget}
    &lt;input type=submit&gt;
|]</codeblock>
  </fig>
  <p id="x5"><codeph id="x-3">selectFieldList</codeph> takes a list of pairs. The first item in the pair is
            the text displayed to the user in the drop-down list, and the second item is the actual
            Haskell value. Of course, the code above looks really repetitive; we can get the same
            result using the Enum and Bounded instance GHC automatically derives for us.</p>
  <fig id="x6">
   <title id="x7">Uses Enum and Bounded</title>
   <codeblock id="x8" outputclass="haskell">{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
    OverloadedStrings, TypeFamilies #-}
import Yesod
import Yesod.Form.Jquery
import Data.Time (Day, getCurrentTime, utctDay, toGregorian)
import Data.Text (Text, pack)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Control.Arrow ((&amp;&amp;&amp;))

data Synopsis = Synopsis

mkYesod "Synopsis" [parseRoutes|
/car CarR GET
|]

instance Yesod Synopsis

-- Necessary for i18n. The default function uses English.
instance RenderMessage Synopsis FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 Synopsis

-- START
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField "Year" (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (selectFieldList colors) "Color" (carColor &lt;$&gt; mcar)
  where
    colors = map (pack . show &amp;&amp;&amp; id) $ [minBound..maxBound]
-- STOP
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = checkM inPast $ checkBool (&gt;= 1990) errorMessage intField

    inPast y = do
        thisYear &lt;- liftIO getCurrentYear
        return $ if y &lt;= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now &lt;- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year

carForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just Black

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) &lt;- runFormGet carForm
    case result of
        FormSuccess car -&gt; defaultLayout [whamlet|&lt;p&gt;#{show car}|]
        _ -&gt; defaultLayout [whamlet|
&lt;form method=get action=@{CarR} enctype=#{enctype}&gt;
    &lt;table&gt;
        ^{widget}
    &lt;input type=submit&gt;
|]</codeblock>
  </fig>
  <p id="x9"><codeph id="x-4">[minBound..maxBound]</codeph> gives us a list of all the different
                <codeph id="x-5">Color</codeph> values. We then apply a <codeph id="x-6">map</codeph> and
                <codeph id="x-7">&amp;&amp;&amp;</codeph> (a.k.a, the fan-out operator) to turn that into a
            list of pairs.</p>
  <p id="x10">Some people prefer radio buttons to drop-down lists. Fortunately, this is just a
            one-word change. For example, see <xref href="#more-sophiticated-fields/radio-buttons"
                format="dita">Radio buttons</xref></p>
  <fig id="radio-buttons">
            <title id="x12">Radio buttons</title>
            <codeblock id="x13" outputclass="haskell">{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
    OverloadedStrings, TypeFamilies #-}
import Yesod
import Yesod.Form.Jquery
import Data.Time (Day, getCurrentTime, utctDay, toGregorian)
import Data.Text (Text, pack)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Control.Arrow ((&amp;&amp;&amp;))

data Synopsis = Synopsis

mkYesod "Synopsis" [parseRoutes|
/car CarR GET
|]

instance Yesod Synopsis

-- Necessary for i18n. The default function uses English.
instance RenderMessage Synopsis FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 Synopsis

-- START
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField "Year" (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (radioFieldList colors) "Color" (carColor &lt;$&gt; mcar)
  where
    colors = map (pack . show &amp;&amp;&amp; id) $ [minBound..maxBound]
-- STOP
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = checkM inPast $ checkBool (&gt;= 1990) errorMessage intField

    inPast y = do
        thisYear &lt;- liftIO getCurrentYear
        return $ if y &lt;= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now &lt;- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year

carForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just Black

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) &lt;- runFormGet carForm
    case result of
        FormSuccess car -&gt; defaultLayout [whamlet|&lt;p&gt;#{show car}|]
        _ -&gt; defaultLayout [whamlet|
&lt;form method=get action=@{CarR} enctype=#{enctype}&gt;
    &lt;table&gt;
        ^{widget}
    &lt;input type=submit&gt;
|]</codeblock>
        </fig>
 </conbody></concept>
