<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="types"><title id="x-1">Types</title><conbody id="x-2">
  <p id="x1">The <apiname id="x2">yesod-form:Yesod.Form.Types</apiname> module declares a few types. Let's start off
   with some simple helpers:</p>
  <dl id="x3">
   <dlentry id="x4">
    <dt id="x5">Enctype</dt>
    <dd id="x6">The encoding type, either <codeph id="x-3">UrlEncoded</codeph> or <codeph id="x-4">Multipart</codeph>.
     This datatype declares an instance of <codeph id="x-5">ToHtml</codeph>, so you can use the enctype
     directly in Hamlet.</dd>
   </dlentry>
   <dlentry id="x7">
    <dt id="x8">Env</dt>
    <dd id="x9">Maps a parameter name to a list of values.</dd>
   </dlentry>
   <dlentry id="x10">
    <dt id="x11">FileEnv</dt>
    <dd id="x12">Maps a parameter name to the associated uploaded file.</dd>
   </dlentry>
   <dlentry id="x13">
    <dt id="x14">Ints</dt>
    <dd id="x15">As mentioned in the introduction, <codeph id="x-6">yesod-form</codeph> automatically assigns
     a unique name to each field. <codeph id="x-7">Ints</codeph> is used to keep track of the next number to
     assign.</dd>
   </dlentry>
   <dlentry id="x16">
    <dt id="x17">FormResult</dt>
    <dd id="x18">Has one of three possible states: <codeph id="x-8">FormMissing</codeph> if no data was
     submitted, <codeph id="x-9">FormFailure</codeph> if there was an error parsing the form (e.g., missing a
     required field, invalid content), or <codeph id="x-10">FormSuccess</codeph> if everything went
     smoothly.</dd>
   </dlentry>
  </dl>
  <p id="x19">Next we have three datatypes used for defining individual fields.</p>
  <note id="x20">A field is a single piece of information, such as a number, a string or an email address.
   Fields are combined together to build forms.</note>
  <dl id="x21">
   <dlentry id="x22">
    <dt id="x23">Field</dt>
    <dd id="x24">Defines two pieces of functionality: how to parse the text input from a user into a
     Haskell value, and how to create the widget to be displayed to the user.
      <codeph id="x-11">yesod-form</codeph> defines a number of individual Fields in <apiname id="x25">yesod-form:Yesod.Form.Fields</apiname>.</dd>
   </dlentry>
   <dlentry id="x26">
    <dt id="x27">FieldSettings</dt>
    <dd id="x28">Basic information on how a field should be displayed, such as the display name, an
     optional tooltip, and possibly hardcoded <codeph id="x-12">id</codeph> and <codeph id="x-13">name</codeph>
     attributes. (If none are provided, they are automatically generated.)<note id="x29"><codeph id="x-14">FieldSettings</codeph> provides an <codeph id="x-15">IsString</codeph> instance, so when you
      need to provide a <codeph id="x-16">FieldSettings</codeph> value, you can actually type in a literal
      string. That's how we interacted with it in the synopsis.</note></dd>
   </dlentry>
   <dlentry id="x30">
    <dt id="x31">FieldView</dt>
    <dd id="x32">An intermediate format containing a bunch of view information on a field. This is hardly
     ever used directly by the user, we'll see more details later.</dd>
   </dlentry>
  </dl>
  <p id="x33">And finally, we get to the important stuff: the forms themselves. There are three
   types for this: <codeph id="x-17">MForm</codeph> is for monadic forms, <codeph id="x-18">AForm</codeph> for
   applicative and <codeph id="x-19">IForm</codeph> (declared in <apiname id="x34">yesod-form:Yesod.Form.Input:IForm</apiname>) for input. <codeph id="x-20">MForm</codeph> is actually a
   type synonym for a monad stack that provides the following features:</p>
  <ul id="ul_cju_elg_md">
   <li id="x35">A <codeph id="x-21">Reader</codeph> monad giving us the parameters (<codeph id="x-22">Env</codeph> and
     <codeph id="x-23">FileEnv</codeph>), the master site argument and the list of languages the user
    supports. The last two are used for i18n (more on this later).</li>
   <li id="x36">A <codeph id="x-24">Writer</codeph> monad keeping track of the <codeph id="x-25">Enctype</codeph>. A
    form will always be <codeph id="x-26">UrlEncoded</codeph>, unless there is a file input field, which will
    force us to use multipart instead.</li>
   <li id="x37">A <codeph id="x-27">State</codeph> monad holding an <codeph id="x-28">Ints</codeph> to keep track of the
    next unique name to produce.</li>
  </ul>
  <p id="x38">An <codeph id="x-29">AForm</codeph> is pretty similar. However, there are a few major
   differences:</p>
  <ul id="ul_atf_olg_md">
   <li id="x39">It produces a list of <codeph id="x-30">FieldViews</codeph>. This allows us to keep an
    abstract idea of the form display, and then at the end of the day choose an appropriate function
    for laying it out on the page. In the synopsis, we used <codeph id="x-31">renderDivs</codeph>, which
    creates a bunch of div tags. Another option would be <codeph id="x-32">renderTable</codeph>.</li>
   <li id="x40">It does not provide a <codeph id="x-33">Monad</codeph> instance. The goal of
     <codeph id="x-34">Applicative</codeph> is to allow the entire form to run, grab as much information on
    each field as possible, and then create the final result. This cannot work in the context of
     <codeph id="x-35">Monad</codeph>.</li>
  </ul>
  <p id="x41">An <codeph id="x-36">IForm</codeph> is even simpler: it returns either a list of error messages
   or a result.</p>
 </conbody></concept>