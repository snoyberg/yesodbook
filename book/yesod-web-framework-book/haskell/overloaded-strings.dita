<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="conceptId">
 <title id="x-1">Overloaded Strings</title>
 <conbody id="x-2">
  <p id="x-3">What's the type of <codeph id="x-4">"hello"</codeph>? Traditionally, it's <codeph id="x-5">String</codeph>, which
   is defined as <codeph id="x-6">type String = [Char]</codeph>. Unfortunately, there are a number of
   limitations with this:</p>
  <ul id="ul_nev_fdx_ff">
   <li id="x-7">It's a very inefficient implementation of textual data. We need to allocate extra memory for
    each cons cell, plus the characters themselves each take up a full machine word.</li>
   <li id="x-8">Sometimes we have string-like data that's not actually text, such as
     <codeph id="x-9">ByteString</codeph>s and HTML.</li>
  </ul>
  <p id="x-10">To work around these limitations, GHC has a language extension called
    <codeph id="x-11">OverloadedStrings</codeph>. When enabled, literal strings no longer have the monomorphic
   type <codeph id="x-12">String</codeph>; instead, they have the type <codeph id="x-13">IsString a =&gt; a</codeph>, where
    <codeph id="x-14">IsString</codeph> is defined as:</p>
  <codeblock id="x-15" outputclass="haskell">class IsString a where
    fromString :: String -&gt; a</codeblock>
  <p id="x-16">There are <codeph id="x-17">IsString</codeph> instances available for a number of types in Haskell, such
   as <codeph id="x-18">Text</codeph> (a much more efficient packed <codeph id="x-19">String</codeph> type),
    <codeph id="x-20">ByteString</codeph>, and <codeph id="x-21">Html</codeph>. Virtually every example in this book
   will assume that this language extension is turned on.</p>
  <p id="x-22">Unfortunately, there is one drawback to this extension: it can sometimes confuse GHC's type
   checker. Imagine we have:</p>
  <codeblock id="x-23" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeSynonymInstances, FlexibleInstances #-}
import Data.Text (Text)

class DoSomething a where
    something :: a -&gt; IO ()

instance DoSomething String where
    something _ = putStrLn "String"

instance DoSomething Text where
    something _ = putStrLn "Text"

myFunc :: IO ()
myFunc = something "hello"</codeblock>
  <p id="x-24">Will the program print out <codeph id="x-25">String</codeph> or <codeph id="x-26">Text</codeph>? It's not clear. So
   instead, you'll need to give an explicit type annotation to specify whether
    <codeph id="x-27">"hello"</codeph> should be treated as a <codeph id="x-28">String</codeph> or
   <codeph id="x-29">Text</codeph>.</p>
 </conbody>
</concept>
