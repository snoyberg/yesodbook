<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="conceptId">
 <title>Type Families</title>
 <conbody>
  <p>The basic idea of a type family is to state some association between two different types.
   Suppose we want to write a function that will safely take the first element of a list. But we
   don't want it to work just on lists; we'd like it to treat a <codeph>ByteString</codeph> like a
   list of <codeph>Word8</codeph>s. To do so, we need to introduce some <term>associated type</term>
   to specify what the contents of a certain type are.</p>
  <codeblock outputclass="haskell">{-# LANGUAGE TypeFamilies, OverloadedStrings #-}
import Data.Word (Word8)
import qualified Data.ByteString as S
import Data.ByteString.Char8 () -- get an orphan IsString instance

class SafeHead a where
    type Content a
    safeHead :: a -> Maybe (Content a)

instance SafeHead [a] where
    type Content [a] = a
    safeHead [] = Nothing
    safeHead (x:_) = Just x

instance SafeHead S.ByteString where
    type Content S.ByteString = Word8
    safeHead bs
        | S.null bs = Nothing
        | otherwise = Just $ S.head bs

main :: IO ()
main = do
    print $ safeHead ("" :: String)
    print $ safeHead ("hello" :: String)

    print $ safeHead ("" :: S.ByteString)
    print $ safeHead ("hello" :: S.ByteString)</codeblock>
  <p>The new syntax is the ability to place a <codeph>type</codeph> inside of a
    <codeph>class</codeph> and <codeph>instance</codeph>. We can also use <codeph>data</codeph>
   instead, which will create a new datatype instead of reference an existing one.</p>
  <note>There are other ways to use associated types outside the context of a typeclass. However, in
   Yesod, all of our associated types are in fact part of a type class. For more information on type
   families, see <xref href="http://www.haskell.org/haskellwiki/GHC/Type_families" format="html"
    scope="external">the Haskell wiki page</xref>.</note>
 </conbody>
</concept>
