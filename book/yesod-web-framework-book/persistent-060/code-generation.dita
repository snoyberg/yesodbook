<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="code-generation"><title id="x-1">Code Generation</title><conbody id="x-2"><p id="bb1">In order to ensure that the PersistEntity instances match up properly with your Haskell datatypes, Persistent takes responsibility for both. This is also good from a DRY (Don't Repeat Yourslef) perspective: you only need to define your entities once. Let's see a quick example:</p><codeblock id="x1" outputclass="haskell">-- START
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

mkPersist sqlSettings [persist|
Person
    name String
    age Int
|]
-- STOP
main = return ()
</codeblock><p id="bb2">We use a combination of Template Haskell and Quasi-Quotation (like when defining
            routes): <apiname id="x6">persistent-template:Database.Persist.TH:persist</apiname> is a
            quasi-quoter which converts a whitespace-sensitive syntax into a list of entity
            definitions. (You can also declare your entities in a separate file using
                <apiname id="x9">persistent-template:Database.Persist.TH:persistFile</apiname>.)
                <apiname id="x10">persistent-template:Database.Persist.TH:mkPersist</apiname> takes that list
            of entities and declares:</p><ul id="x2"><li id="x3">One Haskell datatype for each entity.</li><li id="x4">A <codeph id="x-3">PersistEntity</codeph> instance for each datatype defined.</li></ul>
        <p>The example above generates code that looks like the following:</p>
        <codeblock outputclass="haskell">-- START
{-# LANGUAGE TypeFamilies, GeneralizedNewtypeDeriving, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.Store
import Database.Persist.Sqlite
import Database.Persist.EntityDef
import Control.Monad.IO.Class (liftIO)
import Control.Applicative

data Person = Person
    { personName :: String
    , personAge :: Int
    }
  deriving (Show, Read, Eq)

type PersonId = Key SqlPersist Person

instance PersistEntity Person where
    -- A Generalized Algebraic Datatype (GADT).
    -- This gives us a type-safe approach to matching fields with
    -- their datatypes.
    data EntityField Person typ where
        PersonId   :: EntityField Person PersonId
        PersonName :: EntityField Person String
        PersonAge  :: EntityField Person Int

    type PersistEntityBackend Person = SqlPersist

    toPersistFields (Person name age) =
        [ SomePersistField name
        , SomePersistField age
        ]

    fromPersistValues [nameValue, ageValue] = Person
        &lt;$> fromPersistValue nameValue
        &lt;*> fromPersistValue ageValue
    fromPersistValues _ = Left "Invalid fromPersistValues input"

    -- Information on each field, used internally to generate SQL statements
    persistFieldDef PersonId = FieldDef
        (HaskellName "Id")
        (DBName "id")
        (FTTypeCon Nothing "PersonId")
        []
    persistFieldDef PersonName = FieldDef
        (HaskellName "name")
        (DBName "name")
        (FTTypeCon Nothing "String")
        []
    persistFieldDef PersonAge = FieldDef
        (HaskellName "age")
        (DBName "age")
        (FTTypeCon Nothing "Int")
        []
-- STOP
    data Unique Person typ = IgnoreThis
    entityDef = undefined
    halfDefined = undefined
    persistUniqueToFieldNames = undefined
    persistUniqueToValues = undefined
    persistUniqueKeys = undefined
    persistIdField = undefined
main :: IO ()
main = return ()</codeblock><p id="bb3">As you might expect, our <codeph>Person</codeph> datatype closely matches the definition
            we gave in the original Template Haskell version. We also have a Generalized Algebraic
            Datatype (GADT) which gives a separate constructor for each field. This GADT encodes
            both the type of the entity and the type of the field. We use its constructors
            throughout Persistent, such as to ensure that when we apply a filter, the types of the
            filtering value match the field.</p>
        <p>We can use the generated <codeph>Person</codeph> type like any other Haskell type, and
            then pass it off to other Persistent functions.</p><codeblock id="x5" outputclass="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

mkPersist sqlSettings [persist|
Person
    name String
    age Int
|]
-- START
main = withSqliteConn ":memory:" $ runSqlConn $ do
    michaelId &lt;- insert $ Person "Michael" 26
    michael &lt;- get michaelId
    liftIO $ print michael
-- STOP
</codeblock><p id="bb4">We start off with some standard database connection code. In this case, we used the single-connection functions. Persistent also comes built in with connection pool functions, which we will generally want to use in production.</p><p id="bb5">In this example, we have seen two functions: <codeph id="x-4">insert</codeph> creates a new
            record in the database and returns its ID. Like everything else in Persistent, IDs are
            type safe. We'll get into more details of how these IDs work later. So when you call
                <codeph id="x7">insert $ Person "Michael" 25</codeph>, it gives you a value back of
            type <codeph id="x8">PersonId</codeph>.</p>
<p id="bb6">The next function we see is <codeph id="x-5">get</codeph>, which attempts to load a value from
            the database using an <codeph id="x11">Id</codeph>. In Persistent, you never need to
            worry that you are using the key from the wrong table: trying to load up a different
            entity (like <codeph id="x-6">House</codeph>) using a <codeph id="x12">PersonId</codeph> will
            never compile.</p></conbody></concept>
