<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="migrations"><title id="x-1">Migrations</title><conbody id="x-2"><p id="m1">I'm sorry to tell you, but so far I have lied to you a bit: the example from the previous section does not actually work. If you try to run it, you will get an error message about a missing table.</p><p id="m2">For SQL databases, one of the major pains can be managing schema changes. Instead of leaving this to the user, Persistent steps in to help, but you have to <i id="x1">ask</i> it to help. Let's see what this looks like:</p><codeblock id="x2" outputclass="haskell">-- START
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkSave "entityDefs"] [persist|
Person
    name String
    age Int
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration $ migrate entityDefs (undefined :: Person) -- this line added: that's it!
    michaelId &lt;- insert $ Person "Michael" 26
    michael &lt;- get michaelId
    liftIO $ print michael
-- STOP
</codeblock><p id="m3">With this one little code change, Persistent will automatically create your
                <codeph id="x-3">Person</codeph> table for you. This split between
                <codeph id="x-4">runMigration</codeph> and <codeph id="x-5">migrate</codeph> allows you to migrate
            multiple tables simultaneously.</p><p id="m4">This works when dealing with just a few entities, but can quickly get tiresome once we
            are dealing with a dozen entities. Instead of repeating yourself, Persistent provides a
            helper function, <codeph id="x-6">mkMigrate</codeph>:</p><codeblock id="x3" outputclass="haskell">-- START
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int
    deriving Show
Car
    color String
    make String
    model String
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
-- STOP
</codeblock><p id="m5"><codeph id="x-7">mkMigrate</codeph> is a Template Haskell function which creates a new function
            that will automatically call <codeph id="x-8">migrate</codeph> on all entities defined in the
                <codeph id="x-9">persist</codeph> block. The <codeph id="x-10">share</codeph> function is just a little
            helper that passes the information from the persist block to each Template Haskell
            function and concatenates the results.</p><p id="m6">Persistent has very conservative rules about what it will do during a migration. It
            starts by loading up table information from the database, complete with all defined SQL
            datatypes. It then compares that against the entity definition given in the code. For
            the following cases, it will automatically alter the schema:</p><ul id="x4"><li id="x5">The datatype of a field changed. However, the database may object to this modification if the data cannot be translated.</li><li id="x6">A field was added. However, if the field is not null, no default value is supplied (we'll discuss defaults later) and there is already data in the database, the database will not allow this to happen.</li><li id="x7">A field is converted from not null to null. In the opposite case, Persistent will attempt the conversion, contingent upon the database's approval.</li><li id="x8">A brand new entity is added.</li></ul><p id="m7">However, there are some cases that Persistent will not handle:</p><ul id="x9"><li id="x10">Field or entity renames: Persistent has no way of knowing that "name" has now been renamed to "fullName": all it sees is an old field called name and a new field called fullName.</li><li id="x11">Field removals: since this can result in data loss, Persistent by default will refuse
                to perform the action (you can force the issue by using
                    <codeph id="x-11">runMigrationUnsafe</codeph> instead of <codeph id="x-12">runMigration</codeph>,
                though it is <b id="x12">not</b> recommended).</li></ul><p id="m8"><codeph id="x-13">runMigration</codeph> will print out the migrations it is running on
                <codeph id="x-14">stderr</codeph> (you can bypass this by using
                <codeph id="x-15">runMigrationSilent</codeph>). Whenever possible, it uses <codeph id="x-16">ALTER
                TABLE</codeph> calls. However, in SQLite, <codeph id="x-17">ALTER TABLE</codeph> has very
            limited abilities, and therefore Persistent must resort to copying the data from one
            table to another.</p><p id="m9">Finally, if instead of <i id="x13">performing</i> a migration, you want Persistent to
            give you hints about what migrations are necessary, use the
                <codeph id="x-18">printMigration</codeph> function. This function will print out the
            migrations which <codeph id="x-19">runMigration</codeph> would perform for you. This may be useful
            for performing migrations that Persistent is not capable of, for adding arbitrary SQL to
            a migration, or just to log what migrations occurred.</p><note id="x14" type="other" othertype="advanced"><p id="m10">Although there is no official Persistent integration, there is a Haskell package that
                can assist with running migrations called <apiname id="x15">dbmigrations</apiname>.</p></note></conbody></concept>
