<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="persistbackend"><title id="x-1">PersistStore</title><conbody id="x-2"><p id="bc1">One last detail is left unexplained from the previous example: what are those
                <codeph id="x-3">withSqliteConn</codeph> and <codeph id="x-4">runSqlConn</codeph> functions doing, and
            what is that monad that our database actions are running in?</p><p id="bc2">All database actions need to occur within an instance of <codeph id="x1">PersistStore</codeph>. As its name implies, every data store (PostgreSQL, SQLite,
            MongoDB) has an instance of <codeph id="x-5">PersistStore</codeph>. This is where all the
            translations from <codeph id="x2">PersistValue</codeph> to database-specific values
            occur, where SQL query generation happens, and so on.</p><note id="x3" type="other" othertype="advanced"><p id="bc3">As you can imagine, even though <codeph id="x-6">PersistStore</codeph> provides a safe,
                well-typed interface to the outside world, there are a lot of database interactions
                that could go wrong. However, by testing this code automatically and thoroughly in a
                single location, we can centralize our error-prone code and make sure it is as
                bug-free as possible.</p></note><p id="bc4"><codeph id="x-7">withSqliteConn</codeph> creates a single connection to a database using its
            supplied connection string. For our test cases, we will use <codeph id="x-8">:memory:</codeph>,
            which uses an in-memory database. <codeph id="x-9">runSqlConn</codeph> uses that connection to
            run the inner action. Both SQLite and PostgreSQL share the same instance of
                <codeph id="x-10">PersistStore</codeph>: <codeph id="x-11">SqlPersist</codeph>.</p>
        <note id="x-12">There are actually a few other typeclasses: <codeph id="x-13">PersistUpdate</codeph> and
                <codeph id="x-14">PersistQuery</codeph>. Different typeclasses provide different
            functionality, which allows us to write backends that use simpler data stores (e.g.,
            Redis) even though they can't provide us all the high-level functionality available in
            Persistent.</note><p id="bc5">One important thing to note is that everything which occurs inside a single call to
                <codeph id="x-15">runSqlConn</codeph> runs in a single transaction. This has two important
            implications:</p><ul id="x4"><li id="x5">For many databases, committing a transaction can be a costly activity. By putting multiple steps into a single transaction, you can speed up code dramatically.</li><li id="x6">If an exception is thrown anywhere inside a single call to <codeph id="x-16">runSqlConn</codeph>,
                all actions will be rolled back (assuming your backend has rollback support).</li></ul></conbody></concept>