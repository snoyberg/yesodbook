<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="solving-the-boundary-issue"><title id="x-1">Solving the boundary issue</title><conbody id="x-2"><p id="b1">Suppose you are storing information on people in a SQL database. Your table might look
            something like:</p><codeblock outputclass="sql" id="x1">CREATE TABLE Person(id SERIAL PRIMARY KEY, name VARCHAR NOT NULL, age INTEGER)</codeblock><p id="b2">And if you are using a database like PostgreSQL, you can be guaranteed that the database will never store some arbitrary text in your age field. (The same cannot be said of SQLite, but let's forget about that for now.) To mirror this database table, you would likely create a Haskell datatype that looks something like:</p><codeblock id="x2" outputclass="haskell">data Person = Person
    { personName :: Text
    , personAge :: Int
    }</codeblock><p id="b3">It looks like everything is type safe: the database schema matches our Haskell datatypes, the database ensures that invalid data can never make it into our data store, and everything is generally awesome. Well, until:</p><ul id="x3"><li id="x4">You want to pull data from the database, and the database layer gives you the data in an untyped format.</li><li id="x5">You want to find everyone older than 32, and you accidently write "thirtytwo" in your SQL statement. Guess what: that will compile just fine, and you won't find out you have a problem until runtime.</li><li id="x6">You decide you want to find the first 10 people alphabetically. No problem... until you
                make a typo in your SQL. Once again, you don't find out until runtime.</li></ul><p id="b4">In dynamic languages, the answers to these issues is unit testing. For everything that <i id="x7">can</i> go wrong, make sure you write a test case. But as I am sure you are aware by now, that doesn't jive well with the Yesod approach to things. We like to take advantage of Haskell's strong typing to save us wherever possible, and data storage is no exception.</p><p id="b5">So the question remains: how can we use Haskell's type system to save the day?</p></conbody></concept>