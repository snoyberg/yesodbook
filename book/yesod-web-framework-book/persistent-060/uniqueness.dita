<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="uniqueness"><title id="x-1">Uniqueness</title><conbody id="x-2"><p id="u1">In addition to declaring fields within an entity, you can also declare uniqueness
            constraints. A typical example would be requiring that a username be unique.</p>
        <fig id="x1">
            <title id="x4">Unique Username</title>
            <codeblock outputclass="entities" id="x5">User
    username Text
    UniqueUsername username</codeblock>
        </fig>
        <p id="x6">While each field name must begin with a lowercase letter, the uniqueness constraints must
            begin with an uppercase letter.</p><codeblock id="x2" outputclass="haskell">-- START
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    firstName String
    lastName String
    age Int
    PersonName firstName lastName
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    insert $ Person "Michael" "Snoyman" 26
    michael &lt;- getBy $ PersonName "Michael" "Snoyman"
    liftIO $ print michael
-- STOP</codeblock><p id="u2">To declare a unique combination of fields, we add an extra line to our declaration. Persistent knows that it is defining a unique constructor, since the line begins with a capital letter. Each following word must be a field in this entity.</p><p id="u3">The main restriction on uniqueness is that it can only be applied non-null fields. The
            reason for this is that the SQL standard is ambiguous on how uniqueness should be
            applied to <codeph id="x-3">NULL</codeph> (e.g., is <codeph id="x-4">NULL=NULL</codeph> true or false?).
            Besides that ambiguity, most SQL engines in fact implement rules which would be <i id="x3">contrary</i> to what the Haskell datatypes anticipate (e.g., PostgreSQL says
            that <codeph id="x-5">NULL=NULL</codeph> is false, whereas Haskell says <codeph id="x-6">Nothing ==
                Nothing</codeph> is <codeph id="x-7">True</codeph>).</p>
        <p id="x7">In addition to providing nice guarantees at the database level about consistency
            of your data, uniqueness constraints can also be used to perform some specific queries
            within your Haskell code, like the <codeph id="x-8">getBy</codeph> demonstrated above.
            This happens via the <codeph id="x-9">Unique</codeph> associated type. In the example
            above, we end up with a new constructor:</p>
        <codeblock outputclass="haskell" id="x8">PersonName :: String -&gt; String -&gt; Unique Person</codeblock></conbody></concept>
