<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="response-body"><title id="x-1">Response Body</title><conbody id="x-2"><p id="resbod1">Haskell has a datatype known as a lazy bytestring. By utilizing laziness, you can create large values without exhausting memory. Using lazy I/O, you can do such tricks as having a value which represents the entire contents of a file, yet only occupies a small memory footprint. In theory, a lazy bytestring is the only representation necessary for a response body.</p><p id="resbod2">In practice, while lazy byte strings are wonderful for generating "pure" values, the
            lazy I/O necessary to read a file introduces some non-determinism into our programs.
            When serving thousands of small files a second, the limiting factor is not memory, but
            file handles. Using lazy I/O, file handles may not be freed immediately, leading to
            resource exhaustion. To deal with this, WAI uses <term id="x1">conduits</term>.</p>
        <note>Versions of WAI before 1.0 used enumerators in place of conduits. While both conduits
            and enumerators solve the same basic problem, experience showed that enumerators were
            too constricting in their inversion of control approach, making it difficult to
            structure more complicated systems like a streaming proxy server. Conduits were designed
            with the express purpose of making a better WAI.</note>
        <p>The data type relevant to us now is a <term>source</term>. A source produces a stream of
            data, producing a single chunk at a time. In the case of WAI, the request body would be
            a source passed to the application, and the response body would be a source returned
            from the application.</p><p id="resbod4">There are two further optimizations: many systems provide a sendfile system call, which sends a file directly to a socket, bypassing a lot of the memory copying inherent in more general I/O system calls. Additionally, there is a datatype in Haskell called <codeph id="x5">Builder</codeph> which allows efficient copying of bytes into buffers.</p><p id="resbod5">The WAI response body therefore has three constructors: one for pure builders
                (<codeph id="x6">ResponseBuilder</codeph>), one for a source of builders (<codeph
                id="x7">ResponseSource</codeph>) and one for files (<codeph id="x8"
                >ResponseFile</codeph>).</p></conbody></concept>