<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="web-application-interface"><title id="x-1">Web Application Interface</title><conbody id="x-2"><p id="intro1">It is a problem almost every language used for web development has dealt with: the low level interface between the web server and the application. The earliest example of a solution is the venerable and battle-worn CGI (CGI), providing a language-agnostic interface using only standard input, standard output and environment variables.</p><p id="intro2">Back when Perl was becoming the de facto web programming language, a major shortcoming of CGI became apparent: the process needed to be started anew for each request. When dealing with an interpretted language and application requiring database connection, this overhead became unbearable. FastCGI (and later SCGI) arose as a successor to CGI, but it seems that much of the programming world went in a different direction.</p><p id="intro3">Each language began creating its own standard for interfacing with servers. mod_perl. mod_python. mod_php. mod_ruby. Within the same language, multiple interfaces arose. In some cases, we even had interfaces on top of interfaces. And all of this led to much duplicated effort: a Python application designed to work with FastCGI wouldn't work with mod_python; mod_python only exists for certain webservers; and this programming language specific extensions need to be written for each programming language.</p><p id="intro4">Haskell has its own history. We originally had the <apiname id="x1">cgi</apiname> package, which provided a monadic interface. The <apiname id="x2">fastcgi</apiname> package then provided the same interface. Meanwhile, it seemed that the majority of Haskell web development focused on the standalone server. The problem is that each server comes with its own interface, meaning that you need to target a specific backend. This means that it is impossible to share common features, like GZIP encoding, development servers, and testing frameworks.</p><p id="intro5">WAI attempts to solve this, by providing a generic and efficient interface between web servers and applications. Any <b id="x3">handler</b> supporting the interface can serve any WAI application, while any application using the interface can run on any handler.</p><p id="intro6">At the time of writing, there are various backends, including Warp, FastCGI, and development server. <apiname id="x4">wai-extra</apiname> provides many common middlewares like GZIP, JSON-P and virtual hosting. <apiname id="x5">wai-test</apiname> makes it easy to write unit tests, and <apiname id="x6">wai-handler-devel</apiname> lets you develop your applications without worrying about stopping to compile. Yesod targets WAI, and Happstack is in the process of converting over as well. It's also used by some applications that skip the framework entirely, including the new Hoogle.</p></conbody></concept>