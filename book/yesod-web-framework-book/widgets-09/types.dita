<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="types"><title id="x-1">Types</title><conbody id="x-2">
  <p id="x1">You may have noticed that I've been avoiding type signatures so far. That's because
   there's a little bit of a complication involved here. At the most basic level, all you need to
   know is that there's a type synonym called <codeph>Widget</codeph> which you will almost always
   use. The technical details follow, but don't worry if it's a little hazy.</p>
  <p>There isn't actually a <codeph>Widget</codeph> type defined in the Yesod libraries, since the
   exact meaning of it changes between sites. Instead, we have a more general type <codeph>GWidget
    sub master a</codeph>. The first two parameters give the sub and master foundation types,
   respectively. The final parameter is the contained value, just like any <codeph>Monad</codeph>
   has.</p>
  <p id="x7">So what's the deal with that sub/master stuff? Well, when you're writing some reusable code,
   such as a CRUD application, you can write it as a subsite that can be embedded within any other
   Yesod application. In such a case, we need to keep track of information for both the sub and
   master sites. The simplest example is for the type-safe URLs: Yesod needs to know how to take a
   route for your CRUD subsite and turn it into a route for the master site so that it can be
   properly rendered.</p>
  <p id="x8">However, that sub/master distinction only ever matters when you're interacting with subsites.
   When you're writing your standard response code, you're dealing with just your application, and
   so the sub and master sites will be the same. Since this is the most common case, the scaffolded
   site declares a type synonym to help you out. Let's say your foundation type is MyCoolApp, it
   will define <codeph id="x9">type Widget = GWidget MyCoolApp MyCoolApp ()</codeph>. Therefore, we can get
   some very user-friendly type signatures on our widgets:</p>
  <codeblock outputclass="haskell" id="x10">footer :: Widget
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
&lt;footer&gt;
    &lt;p&gt;That's all folks!
|]

page :: Widget
page = [whamlet|
&lt;p&gt;This is my page. I hope you enjoyed it.
^{footer}
|]</codeblock>
  <p id="x11">If you've been paying close attention, you might be confused. We used
    <codeph>lift</codeph> before on <codeph>Widget</codeph>, but <codeph>GWidget</codeph> isn't
   actually a monad transformer. What's going on here? Well, in older versions of Yesod, it
    <i>was</i> a transformer around the <codeph>Handler</codeph> type. Unfortunately, this led to
   difficult-to-parse error messages. As a result, <codeph>GWidget</codeph> is now a
    <codeph>newtype</codeph> wrapper that hides away its monad-transformer essence. But we still
   want to be able to <codeph>lift</codeph> functions from the inner <codeph>Handler</codeph>
   monad.</p>
  <p>To solve this, Yesod provides an alternate, more general <codeph>lift</codeph> function that
   works for both standard <codeph>MonadTrans</codeph> instances, and special
    <codeph>newtype</codeph> wrappers like <codeph>GWidget</codeph>. As a result, you can pretend
   like <codeph>GWidget</codeph> is a standard transformer, while still getting to keep your nice
   error message.</p>
  <p>One last point: just like we have the breakdown between <codeph>Widget</codeph> and
    <codeph>GWidget</codeph>, we have a similar breakdown between <codeph>Handler</codeph> and
    <codeph>GHandler</codeph>.</p>
 </conbody></concept>