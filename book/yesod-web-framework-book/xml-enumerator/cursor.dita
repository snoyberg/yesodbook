<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/concept.dtd">
<concept id="cursor">
 <title>Cursor</title>
 <conbody>
  <p>Let's say you want to pull the title out of an XHTML document. You could do so with the
   Text.XML interface we just described, using standard pattern matching on the children of
   elements. But that would get very tedious, very quickly. Probably the gold standard for these
   kinds of lookups is XPath, where you would be able to write <codeph>/html/head/title</codeph>.
   And that's exactly what inspired the design of the
    <apiname>xml-enumerator:Text.XML.Cursor</apiname> combinators.</p>
  <p>A cursor is an XML node that knows its location in the tree; it's able to traverse upwards,
   sideways, and downwards. (Under the surface, this is achieved by <xref
    href="http://www.haskell.org/haskellwiki/Tying_the_Knot" format="html" scope="external">tying
    the knot</xref>.) There are two functions available for creating cursors from Text.XML types:
   fromDocument and fromNode.</p>
  <p>We also have the concept of an <term>Axis</term>, defined as <codeph>type Axis = Cursor ->
    [Cursor]</codeph>. It's easiest to get started by simply looking at example axes: child returns
   zero or more cursors that are the child of the current one, parent returns the single parent
   cursor of the input, or an empty list if the input is the root element, and so on.</p>
  <p>In addition, there are some axes that take predicates. <codeph>element</codeph> is a commonly
   used function that filters down to only elements which match the given name. For example,
    <codeph>element "title"</codeph> will return the input element if its name is "title", or an
   empty list otherwise.</p>
  <p>Another common function which isn't quite an axis is <codeph>content :: Cursor ->
    [Text]</codeph>. For all content nodes, it returns the contained text; otherwise, it returns an
   empty list.</p>
  <p>And thanks to the monad instance for lists, it's very easy to string all of these together. For
   example, to do our title lookup, we would write the following program:</p>
  <codeblock outputclass="haskell">{-# LANGUAGE OverloadedStrings #-}
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc &lt;- readFile_ def "test.xml"
    let cursor = fromDocument doc
    print $ T.concat $
            child cursor >>= element "head" >>= child
                         >>= element "title" >>= descendant >>= content</codeblock>
  <p>What this says is:</p>
  <ol id="ol_d37c1613-8879-4be8-862c-9823d88f5b90">
   <li>Get me all the child nodes of the root element</li>
   <li>Filter down to only the elements named "head"</li>
   <li>Get all the children of all those head elements</li>
   <li>Filter down to only the elements named "title"</li>
   <li>Get all the descendants of all those title elements. (A descendant is a child, or a
    descendant of a child. Yes, that was a recursive definition.)</li>
   <li>Get only the text nodes.</li>
  </ol>
  <p>So for the input document:</p>
  <codeblock outputclass="xml">&lt;html>
    &lt;head>
        &lt;title>My &lt;b>Title&lt;/b>&lt;/title>
    &lt;/head>
    &lt;body>
        &lt;p>Foo bar baz&lt;/p>
    &lt;/body>
&lt;/html></codeblock>
  <p>We end up with the output <codeph>My Title</codeph>. This is all well and good, but it's much
   more verbose than the XPath solution. To combat this verbosity, Aristid Breitkreuz added a set of
   operators to the Cursor module to handle many common cases. So we can rewrite our example as:</p>
  <codeblock outputclass="haskell">{-# LANGUAGE OverloadedStrings #-}
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc &lt;- readFile_ def "test.xml"
    let cursor = fromDocument doc
    print $ T.concat $
        cursor $/ element "head" &amp;/ element "title" &amp;// content</codeblock>
  <p><codeph>$/</codeph> says to apply the axis on the right to the cursor on the left.
    <codeph>&amp;/</codeph> is almost identical, but is instead used to combine two axes together.
   This is a general rule in Text.XML.Cursor: operators beginning with $ directly apply an axis,
   while &amp; will combine two together. <codeph>&amp;//</codeph> is used for applying an axis to
   all descendants.</p>
  <p>Let's go for a more complex, if more contrived, example. We have a document that looks
   like:</p>
  <codeblock outputclass="xml">&lt;html>
    &lt;head>
        &lt;title>Headings&lt;/title>
    &lt;/head>
    &lt;body>
        &lt;hgroup>
            &lt;h1>Heading 1 foo&lt;/h1>
            &lt;h2 class="foo">Heading 2 foo&lt;/h2>
        &lt;/hgroup>
        &lt;hgroup>
            &lt;h1>Heading 1 bar&lt;/h1>
            &lt;h2 class="bar">Heading 2 bar&lt;/h2>
        &lt;/hgroup>
    &lt;/body>
&lt;/html></codeblock>
  <p>We want to get the content of all the <codeph>h1</codeph> tags which precede an
    <codeph>h2</codeph> tag with a <codeph>class</codeph> attribute of "bar". To perform this
   convoluted lookup, we can write:</p>
  <codeblock outputclass="haskell">{-# LANGUAGE OverloadedStrings #-}
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc &lt;- readFile_ def "test2.xml"
    let cursor = fromDocument doc
    print $ T.concat $
        cursor $// element "h2"
               >=> attributeIs "class" "bar"
               >=> precedingSibling
               >=> element "h1"
               &amp;// content</codeblock>
  <p>Let's step through that. First we get all h2 elements in the document. ($// gets all
   descendants of the root element.) Then we filter out only those with class=bar. That
    <codeph>>=></codeph> operator is actually the standard operator from
    <apiname>base:Control.Monad</apiname>; yet another advantage of the monad instance of lists.
   precedingSibling finds all nodes that come before our node <b>and</b> share the same parent.
   (There is also a <codeph>preceding</codeph> axis which simply takes all elements earlier in the
   tree.) We then take just the h1 elements, and then grab their content.</p>
  <note>The equivalent XPath, for comparison, would be <codeph>//h2[@class =
    'bar']/preceding-sibling::h1//text()</codeph>.</note>
  <p>While the cursor API isn't quite as succinct as XPath, it has the advantages of being standard
   Haskell code, and of type safety.</p>
 </conbody>
</concept>
