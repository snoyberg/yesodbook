<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="rendering-and-parsing-urls"><title id="x-1">Rendering and Parsing URLs</title><conbody id="x-2"><p id="rpu1">We've already mentioned how Yesod is able to automatically render type-safe URLs into a textual URL that can be inserted into an HTML page. Let's say we have a route definition that looks like:</p><codeblock outputclass="haskell" id="x1">mkYesod "MyApp" [parseRoutes|
/some/path SomePathR GET
]</codeblock><p id="rpu2">If we place <codeph>SomePathR</codeph> into a hamlet template, how does Yesod render
            it? Yesod always tries to construct <i id="x2">absolute</i> URLs. This is especially
            useful once we start creating XML sitemaps and Atom feeds, or sending emails. But in
            order to construct an absolute URL, we need to know the domain name of the
            application.</p><p id="rpu3">You might think we could get that information from the user's request, but we still
            need to deal with ports. And even if we get the port number from the request, are we
            using HTTP or HTTPS? And even if you know <i id="x3">that</i>, such an approach would
            break one of our RESTful principles: depending on how the user submitted a request would
            generate different URLs. For example, we would generate different URLs depending if the
            user connected to "example.com" or "www.example.com".</p><p id="rpu4">And finally, Yesod doesn't make any assumption about <i id="x4">where</i> you host your application. For example, I may have a mostly static site (http://static.example.com/), but I'd like to stick a Yesod-powered Wiki at /wiki/. There is no reliable way for an application to determine what subpath it is being hosted from. So instead of doing all of this guesswork, Yesod needs you to tell it the <term id="x5">application root</term>.</p><p id="rpu5">Using the wiki example, you would write your <codeph>Yesod</codeph> instance as:</p><codeblock outputclass="haskell" id="x6">instance Yesod MyWiki where
    approot _ = "http://static.example.com/wiki"</codeblock><p id="rpu6">Notice that there is no trailing slash there. Next, when Yesod wants to construct a URL
            for <codeph>SomePathR</codeph>, it determines that the relative path for
                <codeph>SomePathR</codeph> is <codeph>/some/path</codeph>, appends that to your
            approot and creates <codeph>http://static.example.com/wiki/some/path</codeph>.</p><p id="rpu7">This also explains our cryptic <codeph id="x7">approot _ = ""</codeph>: for our
            examples in the book, we're always serving from the root of the domain (in our case,
                <codeph>localhost</codeph>). By using an empty string, <codeph>SomePathR</codeph>
            renders to <codeph>/some/path</codeph>, which works just fine. In real life
            applications, however, you should use a real application root.</p>
<note id="x13">The first argument to <codeph>approot</codeph> is the site foundation. This means
            that you could load your approot at program initialization, store it in the foundation,
            and then retrieve it. This is in fact what the scaffolded site does, using a YAML config
            file.</note>
<p id="rpu8">And by the way, the site template generated by the scaffolding tool can load different
            settings for developing, testing, staging, and production builds, so you can easily test
            on one domain- like localhost- and serve from a different domain.</p><note id="x8"><p id="rpu9">To reiterate: even though for the simple cases in this book, the first argument to
                    <codeph>approot</codeph> is usually ignored, in real life code it usually isn't.
                We also need to keep that argument so that Haskell's type system can determine which
                instance of <codeph>Yesod</codeph> to use in grabbing the
                <codeph>approot</codeph>.</p></note></conbody></concept>
